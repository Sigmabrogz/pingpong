<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong Wars - On-Chain ETH Betting Battle</title>
    <meta
      name="description"
      content="The eternal battle between day and night with real ETH betting on Ethereum!"
    />
    <meta name="theme-color" content="#172B36" />
    <style>
      html {
        height: 100%;
      }

      body {
        height: 100%;
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(to bottom, #172b36 0%, #d9e8e3 100%);
        font-family: monospace;
      }

      #container {
        display: flex;
        align-items: center;
        flex-direction: column;
        width: min(70vh, 80%);
        max-width: 600px;
        height: 100%;
      }

      canvas {
        display: block;
        border-radius: 4px;
        overflow: hidden;
        width: 100%;
        margin-top: auto;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
      }

      #gameInfo {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-top: 20px;
        padding: 0 20px;
        box-sizing: border-box;
      }

      #timer {
        font-size: 24px;
        font-weight: bold;
        color: #FF9932;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      }

      #score {
        font-size: 16px;
        color: #172b36;
      }

      #walletSection {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 10px;
        padding: 15px;
        margin-top: 20px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        width: 100%;
        box-sizing: border-box;
      }

      #connectWallet {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        cursor: pointer;
        font-family: monospace;
        font-size: 16px;
        font-weight: bold;
        transition: background 0.3s;
      }

      #connectWallet:hover {
        background: #45a049;
      }

      #connectWallet:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      #walletInfo {
        margin-top: 10px;
        font-size: 14px;
        color: #172B36;
      }

      #bettingSection {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        width: 100%;
        box-sizing: border-box;
      }

      #bettingSection h3 {
        margin: 0 0 15px 0;
        color: #172B36;
        font-size: 18px;
      }

      .player-section {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        justify-content: space-between;
      }

      .player-card {
        flex: 1;
        padding: 15px;
        border-radius: 10px;
        border: 2px solid transparent;
        transition: all 0.3s;
      }

      .player-day {
        background: #D9E8E3;
        color: #114C5A;
      }

      .player-night {
        background: #114C5A;
        color: #D9E8E3;
      }

      .player-card.ready {
        border-color: #4CAF50;
        box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
      }

      .player-card h4 {
        margin: 0 0 10px 0;
        font-size: 16px;
      }

      .player-wallet {
        font-size: 12px;
        margin-bottom: 10px;
        font-weight: bold;
        word-break: break-all;
      }

      .bet-input {
        width: 80px;
        padding: 8px;
        border: 2px solid currentColor;
        border-radius: 5px;
        text-align: center;
        font-family: monospace;
        font-size: 14px;
        margin-bottom: 10px;
      }

      .ready-btn {
        background: #4CAF50;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-family: monospace;
        font-size: 14px;
        transition: background 0.3s;
      }

      .ready-btn:hover {
        background: #45a049;
      }

      .ready-btn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      .cancel-btn {
        background: #f44336;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        cursor: pointer;
        font-family: monospace;
        font-size: 14px;
        margin-left: 5px;
      }

      #matchInfo {
        background: rgba(255, 255, 255, 0.8);
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 15px;
        font-weight: bold;
        color: #172B36;
      }

      #gameOver {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        color: white;
        text-align: center;
        z-index: 1000;
      }

      #gameOver h1 {
        font-size: 48px;
        margin: 0 0 20px 0;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      }

      #gameOver p {
        font-size: 24px;
        margin: 10px 0;
      }

      #betResults {
        font-size: 20px;
        margin: 15px 0;
        font-weight: bold;
      }

      .win-result {
        color: #4CAF50;
      }

      .lose-result {
        color: #F44336;
      }

      #restartBtn, #startBtn {
        background: #114C5A;
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        font-family: monospace;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
        transition: background 0.3s;
      }

      #restartBtn:hover, #startBtn:hover {
        background: #172B36;
      }

      #startBtn:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      #made {
        text-align: center;
        line-height: 1.5;
        font-family: monospace;
        margin-top: auto;
        margin-bottom: 20px;
        font-size: 10px;
      }

      #made a {
        color: #172b36;
      }

      .winner-day {
        color: #D9E8E3 !important;
        text-shadow: 2px 2px 4px #114C5A;
      }

      .winner-night {
        color: #114C5A !important;
        text-shadow: 2px 2px 4px #D9E8E3;
      }

      .hidden {
        display: none !important;
      }

      .waiting-message {
        font-style: italic;
        color: #666;
        margin-top: 10px;
        font-size: 12px;
      }

      .loading {
        opacity: 0.6;
        pointer-events: none;
      }

      .tx-hash {
        font-size: 10px;
        color: #666;
        margin-top: 5px;
        word-break: break-all;
      }

      .network-info {
        background: rgba(255, 193, 7, 0.2);
        border: 1px solid #FFC107;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 15px;
        font-size: 12px;
        color: #856404;
      }

      .error-message {
        background: rgba(220, 53, 69, 0.1);
        border: 1px solid #dc3545;
        border-radius: 5px;
        padding: 10px;
        margin: 10px 0;
        color: #721c24;
        font-size: 14px;
      }

      .debug-info {
        background: rgba(0, 123, 255, 0.1);
        border: 1px solid #007bff;
        border-radius: 5px;
        padding: 10px;
        margin: 10px 0;
        color: #004085;
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <div id="container">
      <canvas id="pongCanvas" width="600" height="600"></canvas>
      <div id="gameInfo">
        <div id="timer">1:00</div>
        <div id="score"></div>
      </div>
      
      <!-- Wallet Connection Section -->
      <div id="walletSection">
        <button id="connectWallet">Connect MetaMask</button>
        <div id="walletInfo" class="hidden">
          <div>Connected: <span id="walletAddress"></span></div>
          <div>Balance: <span id="walletBalance">0</span> ETH</div>
        </div>
        <div class="network-info">
          üåê Make sure you're on <strong>Sepolia Testnet</strong> to play!
        </div>
        <div id="debugInfo" class="debug-info hidden">
          Debug: <span id="debugText">Checking MetaMask...</span>
        </div>
      </div>
      
      <div id="bettingSection" class="hidden">
        <h3>üîó On-Chain ETH Betting</h3>
        
        <div id="matchInfo" class="hidden">
          Game ID: <span id="gameIdDisplay">-</span> | Total Pot: <span id="totalPot">0</span> ETH
          <br><small>Winner gets 70% ‚Ä¢ Platform fee: 30%</small>
        </div>
        
        <div class="player-section">
          <div class="player-card player-day" id="dayPlayer">
            <h4>üåÖ DAY PLAYER</h4>
            <div class="player-wallet" id="dayWalletDisplay">Connect wallet to play</div>
            <input type="number" class="bet-input" id="dayBetInput" value="0.01" min="0.001" step="0.001" placeholder="ETH amount">
            <br>
            <button class="ready-btn" id="dayReadyBtn" disabled>Create Game</button>
            <button class="cancel-btn hidden" id="dayCancelBtn">Cancel</button>
            <div id="dayStatus" class="waiting-message"></div>
          </div>
          
          <div class="player-card player-night" id="nightPlayer">
            <h4>üåô NIGHT PLAYER</h4>
            <div class="player-wallet" id="nightWalletDisplay">Connect wallet to play</div>
            <input type="number" class="bet-input" id="nightBetInput" value="0.01" min="0.001" step="0.001" placeholder="ETH amount">
            <br>
            <button class="ready-btn" id="nightReadyBtn" disabled>Join Game</button>
            <button class="cancel-btn hidden" id="nightCancelBtn">Cancel</button>
            <div id="nightStatus" class="waiting-message"></div>
          </div>
        </div>
        
        <div id="errorMessage" class="error-message hidden"></div>
      </div>

      <button id="startBtn" disabled class="hidden">Start Battle!</button>
      
      <p id="made">
        On-chain ETH betting battle | Contract: 0x86ACF0c26e09A045f1AE44b1a7d8A43c1a052538
        <br>made by <a href="https://x.com/0x_vivek">0x_vivek</a>
      </p>
    </div>

    <div id="gameOver">
      <h1 id="winnerText">GAME OVER</h1>
      <p id="finalScore"></p>
      <p id="winMessage"></p>
      <div id="betResults"></div>
      <button id="restartBtn">Play Again</button>
    </div>

    <!-- Load ethers.js with multiple fallbacks -->
    <script>
      // Load ethers.js with fallback CDNs
      function loadEthers() {
        return new Promise((resolve, reject) => {
          const cdnUrls = [
            'https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js',
            'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
            'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
          ];
          
          let currentIndex = 0;
          
          function tryLoad() {
            if (currentIndex >= cdnUrls.length) {
              reject(new Error('Failed to load ethers.js from all CDNs'));
              return;
            }
            
            const script = document.createElement('script');
            script.src = cdnUrls[currentIndex];
            script.onload = () => {
              if (typeof ethers !== 'undefined') {
                console.log('‚úÖ Ethers.js loaded from:', cdnUrls[currentIndex]);
                resolve();
              } else {
                currentIndex++;
                tryLoad();
              }
            };
            script.onerror = () => {
              console.warn('‚ùå Failed to load from:', cdnUrls[currentIndex]);
              currentIndex++;
              tryLoad();
            };
            document.head.appendChild(script);
          }
          
          tryLoad();
        });
      }

      // Initialize everything after ethers.js loads
      async function initializeApp() {
        try {
          await loadEthers();
          debug('Ethers.js loaded successfully!');
          setupApp();
        } catch (error) {
          debug('Failed to load ethers.js: ' + error.message);
          showError('Failed to load Web3 library. Please refresh the page.');
        }
      }

      function setupApp() {
        // Game constants
        const colorPalette = {
          ArcticPowder: "#F1F6F4",
          MysticMint: "#D9E8E3",
          Forsythia: "#FFC801",
          DeepSaffron: "#FF9932",
          NocturnalExpedition: "#114C5A",
          OceanicNoir: "#172B36",
        };

        const canvas = document.getElementById("pongCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.getElementById("score");
        const timerElement = document.getElementById("timer");
        const gameOverElement = document.getElementById("gameOver");
        const winnerTextElement = document.getElementById("winnerText");
        const finalScoreElement = document.getElementById("finalScore");
        const winMessageElement = document.getElementById("winMessage");
        const startBtnElement = document.getElementById("startBtn");
        const bettingSectionElement = document.getElementById("bettingSection");

        const DAY_COLOR = colorPalette.MysticMint;
        const DAY_BALL_COLOR = colorPalette.NocturnalExpedition;
        const NIGHT_COLOR = colorPalette.NocturnalExpedition;
        const NIGHT_BALL_COLOR = colorPalette.MysticMint;
        const SQUARE_SIZE = 25;
        const MIN_SPEED = 5;
        const MAX_SPEED = 10;

        const numSquaresX = canvas.width / SQUARE_SIZE;
        const numSquaresY = canvas.height / SQUARE_SIZE;

        // Web3 variables
        let provider = null;
        let signer = null;
        let contract = null;
        let userAddress = null;
        let currentGameId = null;
        let userRole = null; // 'day' or 'night'

        // Contract configuration
        const CONTRACT_ADDRESS = "0x86ACF0c26e09A045f1AE44b1a7d8A43c1a052538";
        const CONTRACT_ABI = [
          {
            "inputs": [],
            "stateMutability": "nonpayable",
            "type": "constructor"
          },
          {
            "anonymous": false,
            "inputs": [
              {
                "indexed": true,
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "indexed": true,
                "internalType": "address",
                "name": "winner",
                "type": "address"
              },
              {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
              },
              {
                "indexed": false,
                "internalType": "uint256",
                "name": "platformFee",
                "type": "uint256"
              }
            ],
            "name": "FundsDistributed",
            "type": "event"
          },
          {
            "anonymous": false,
            "inputs": [
              {
                "indexed": true,
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "indexed": true,
                "internalType": "address",
                "name": "dayPlayer",
                "type": "address"
              },
              {
                "indexed": false,
                "internalType": "uint256",
                "name": "dayBet",
                "type": "uint256"
              }
            ],
            "name": "GameCreated",
            "type": "event"
          },
          {
            "anonymous": false,
            "inputs": [
              {
                "indexed": true,
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "indexed": false,
                "internalType": "enum PongWarsBetting.Winner",
                "name": "winner",
                "type": "uint8"
              }
            ],
            "name": "GameEnded",
            "type": "event"
          },
          {
            "anonymous": false,
            "inputs": [
              {
                "indexed": true,
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              }
            ],
            "name": "GameStarted",
            "type": "event"
          },
          {
            "anonymous": false,
            "inputs": [
              {
                "indexed": true,
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "indexed": true,
                "internalType": "address",
                "name": "nightPlayer",
                "type": "address"
              },
              {
                "indexed": false,
                "internalType": "uint256",
                "name": "nightBet",
                "type": "uint256"
              }
            ],
            "name": "PlayerJoined",
            "type": "event"
          },
          {
            "inputs": [],
            "name": "PLATFORM_FEE_PERCENT",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "internalType": "enum PongWarsBetting.Winner",
                "name": "_winner",
                "type": "uint8"
              }
            ],
            "name": "announceWinner",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              }
            ],
            "name": "cancelGame",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "createGame",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "stateMutability": "payable",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "name": "games",
            "outputs": [
              {
                "internalType": "address",
                "name": "dayPlayer",
                "type": "address"
              },
              {
                "internalType": "address",
                "name": "nightPlayer",
                "type": "address"
              },
              {
                "internalType": "uint256",
                "name": "dayBet",
                "type": "uint256"
              },
              {
                "internalType": "uint256",
                "name": "nightBet",
                "type": "uint256"
              },
              {
                "internalType": "enum PongWarsBetting.GameState",
                "name": "state",
                "type": "uint8"
              },
              {
                "internalType": "enum PongWarsBetting.Winner",
                "name": "winner",
                "type": "uint8"
              },
              {
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              },
              {
                "internalType": "bool",
                "name": "fundsDistributed",
                "type": "bool"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "getActiveGames",
            "outputs": [
              {
                "internalType": "uint256[]",
                "name": "",
                "type": "uint256[]"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "getContractBalance",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              }
            ],
            "name": "getGame",
            "outputs": [
              {
                "components": [
                  {
                    "internalType": "address",
                    "name": "dayPlayer",
                    "type": "address"
                  },
                  {
                    "internalType": "address",
                    "name": "nightPlayer",
                    "type": "address"
                  },
                  {
                    "internalType": "uint256",
                    "name": "dayBet",
                    "type": "uint256"
                  },
                  {
                    "internalType": "uint256",
                    "name": "nightBet",
                    "type": "uint256"
                  },
                  {
                    "internalType": "enum PongWarsBetting.GameState",
                    "name": "state",
                    "type": "uint8"
                  },
                  {
                    "internalType": "enum PongWarsBetting.Winner",
                    "name": "winner",
                    "type": "uint8"
                  },
                  {
                    "internalType": "uint256",
                    "name": "gameId",
                    "type": "uint256"
                  },
                  {
                    "internalType": "bool",
                    "name": "fundsDistributed",
                    "type": "bool"
                  }
                ],
                "internalType": "struct PongWarsBetting.Game",
                "name": "",
                "type": "tuple"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "uint256",
                "name": "gameId",
                "type": "uint256"
              }
            ],
            "name": "joinGame",
            "outputs": [],
            "stateMutability": "payable",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "nextGameId",
            "outputs": [
              {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "owner",
            "outputs": [
              {
                "internalType": "address",
                "name": "",
                "type": "address"
              }
            ],
            "stateMutability": "view",
            "type": "function"
          },
          {
            "inputs": [
              {
                "internalType": "address",
                "name": "newOwner",
                "type": "address"
              }
            ],
            "name": "transferOwnership",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          },
          {
            "inputs": [],
            "name": "withdrawPlatformFees",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
          }
        ];

        // Game variables
        let dayScore = 0;
        let nightScore = 0;
        let gameRunning = false;
        let gameStartTime = 0;
        let gameDuration = 60000; // 1 minute in milliseconds
        let gameInterval;
        let timerInterval;

        const squares = [];
        let balls = [];

        // Web3 Functions
        async function connectWallet() {
          try {
            debug('Starting wallet connection...');
            
            const connectBtn = document.getElementById('connectWallet');
            connectBtn.disabled = true;
            connectBtn.textContent = 'Connecting...';

            // Check if MetaMask is installed
            if (typeof window.ethereum === 'undefined') {
              debug('MetaMask not found');
              showError('MetaMask is not installed! Please install MetaMask to play.');
              connectBtn.disabled = false;
              connectBtn.textContent = 'Connect MetaMask';
              return;
            }

            debug('MetaMask detected, requesting accounts...');

            // Request account access
            const accounts = await window.ethereum.request({ 
              method: 'eth_requestAccounts' 
            });
            
            if (accounts.length === 0) {
              debug('No accounts returned');
              showError('No accounts found. Please unlock MetaMask.');
              connectBtn.disabled = false;
              connectBtn.textContent = 'Connect MetaMask';
              return;
            }

            debug(`Account found: ${accounts[0]}`);
            
            // Create provider and signer
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();
            userAddress = await signer.getAddress();
            
            debug(`Signer address: ${userAddress}`);
            
            // Check network
            const network = await provider.getNetwork();
            debug(`Network: ${network.name} (${network.chainId})`);
            
            if (network.chainId !== 11155111) { // Sepolia chainId
              showError('Please switch to Sepolia testnet in MetaMask!');
              connectBtn.disabled = false;
              connectBtn.textContent = 'Connect MetaMask';
              return;
            }
            
            // Create contract instance
            contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
            debug('Contract instance created');
            
            // Update UI
            document.getElementById('walletAddress').textContent = 
              userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
            
            await updateBalance();
            
            document.getElementById('walletInfo').classList.remove('hidden');
            document.getElementById('bettingSection').classList.remove('hidden');
            connectBtn.classList.add('hidden');
            
            updatePlayerUI();
            
            debug('Wallet connection successful!');
            document.getElementById('debugInfo').classList.add('hidden');
            
            console.log('‚úÖ Wallet connected:', userAddress);
            
          } catch (error) {
            console.error('‚ùå Wallet connection failed:', error);
            debug(`Connection failed: ${error.message}`);
            showError('Failed to connect wallet: ' + error.message);
            
            const connectBtn = document.getElementById('connectWallet');
            connectBtn.disabled = false;
            connectBtn.textContent = 'Connect MetaMask';
          }
        }

        async function updateBalance() {
          try {
            const balance = await provider.getBalance(userAddress);
            const ethBalance = ethers.utils.formatEther(balance);
            document.getElementById('walletBalance').textContent = parseFloat(ethBalance).toFixed(4);
          } catch (error) {
            console.error('Failed to update balance:', error);
          }
        }

        function updatePlayerUI() {
          const dayWallet = document.getElementById('dayWalletDisplay');
          const nightWallet = document.getElementById('nightWalletDisplay');
          const dayBtn = document.getElementById('dayReadyBtn');
          const nightBtn = document.getElementById('nightReadyBtn');
          
          if (userAddress) {
            const shortAddress = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
            dayWallet.textContent = `Your wallet: ${shortAddress}`;
            nightWallet.textContent = `Your wallet: ${shortAddress}`;
            dayBtn.disabled = false;
            nightBtn.disabled = false;
          }
        }

        async function createGame() {
          try {
            const betAmount = document.getElementById('dayBetInput').value;
            if (!betAmount || parseFloat(betAmount) <= 0) {
              showError('Please enter a valid bet amount!');
              return;
            }

            const dayBtn = document.getElementById('dayReadyBtn');
            dayBtn.disabled = true;
            dayBtn.textContent = 'Creating...';
            
            showStatus('day', 'Creating game on blockchain...');
            
            // Send transaction
            const tx = await contract.createGame({
              value: ethers.utils.parseEther(betAmount)
            });
            
            showStatus('day', `Transaction sent: ${tx.hash.slice(0, 10)}...`);
            
            // Wait for confirmation
            const receipt = await tx.wait();
            
            // Get game ID from event
            const gameCreatedEvent = receipt.events.find(e => e.event === 'GameCreated');
            currentGameId = gameCreatedEvent.args.gameId.toNumber();
            userRole = 'day';
            
            // Update UI
            document.getElementById('gameIdDisplay').textContent = currentGameId;
            document.getElementById('totalPot').textContent = betAmount;
            document.getElementById('matchInfo').classList.remove('hidden');
            
            document.getElementById('dayPlayer').classList.add('ready');
            dayBtn.classList.add('hidden');
            document.getElementById('dayCancelBtn').classList.remove('hidden');
            
            showStatus('day', `Game created! ID: ${currentGameId} - Waiting for Night player...`);
            showStatus('night', 'Join this game to start the battle!');
            
            console.log('‚úÖ Game created:', currentGameId);
            
          } catch (error) {
            console.error('‚ùå Failed to create game:', error);
            showError('Failed to create game: ' + error.message);
            
            const dayBtn = document.getElementById('dayReadyBtn');
            dayBtn.disabled = false;
            dayBtn.textContent = 'Create Game';
          }
        }

        async function joinGame() {
          try {
            if (!currentGameId) {
              showError('No active game to join! Day player must create a game first.');
              return;
            }

            const betAmount = document.getElementById('nightBetInput').value;
            if (!betAmount || parseFloat(betAmount) <= 0) {
              showError('Please enter a valid bet amount!');
              return;
            }

            const nightBtn = document.getElementById('nightReadyBtn');
            nightBtn.disabled = true;
            nightBtn.textContent = 'Joining...';
            
            showStatus('night', 'Joining game on blockchain...');
            
            // Send transaction
            const tx = await contract.joinGame(currentGameId, {
              value: ethers.utils.parseEther(betAmount)
            });
            
            showStatus('night', `Transaction sent: ${tx.hash.slice(0, 10)}...`);
            
            // Wait for confirmation
            await tx.wait();
            
            userRole = 'night';
            
            // Update UI
            const dayBet = parseFloat(document.getElementById('dayBetInput').value);
            const nightBet = parseFloat(betAmount);
            const totalPot = dayBet + nightBet;
            
            document.getElementById('totalPot').textContent = totalPot.toFixed(3);
            document.getElementById('nightPlayer').classList.add('ready');
            nightBtn.classList.add('hidden');
            
            showStatus('day', `Night player joined! Total pot: ${totalPot.toFixed(3)} ETH`);
            showStatus('night', `Joined game! Total pot: ${totalPot.toFixed(3)} ETH`);
            
            // Show start button
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('startBtn').disabled = false;
            
            console.log('‚úÖ Joined game:', currentGameId);
            
          } catch (error) {
            console.error('‚ùå Failed to join game:', error);
            showError('Failed to join game: ' + error.message);
            
            const nightBtn = document.getElementById('nightReadyBtn');
            nightBtn.disabled = false;
            nightBtn.textContent = 'Join Game';
          }
        }

        async function cancelGame() {
          try {
            if (!currentGameId || userRole !== 'day') {
              showError('Only the day player can cancel the game!');
              return;
            }

            const cancelBtn = document.getElementById('dayCancelBtn');
            cancelBtn.disabled = true;
            cancelBtn.textContent = 'Canceling...';
            
            // Send transaction
            const tx = await contract.cancelGame(currentGameId);
            await tx.wait();
            
            // Reset UI
            resetBettingUI();
            showStatus('day', 'Game canceled. Your ETH has been returned.');
            
            console.log('‚úÖ Game canceled:', currentGameId);
            
          } catch (error) {
            console.error('‚ùå Failed to cancel game:', error);
            showError('Failed to cancel game: ' + error.message);
            
            const cancelBtn = document.getElementById('dayCancelBtn');
            cancelBtn.disabled = false;
            cancelBtn.textContent = 'Cancel';
          }
        }

        function showStatus(player, message) {
          document.getElementById(`${player}Status`).textContent = message;
        }

        function showError(message) {
          const errorDiv = document.getElementById('errorMessage');
          errorDiv.textContent = message;
          errorDiv.classList.remove('hidden');
          setTimeout(() => {
            errorDiv.classList.add('hidden');
          }, 5000);
        }

        function resetBettingUI() {
          currentGameId = null;
          userRole = null;
          
          // Reset buttons
          ['day', 'night'].forEach(side => {
            document.getElementById(`${side}Player`).classList.remove('ready');
            document.getElementById(`${side}ReadyBtn`).classList.remove('hidden');
            document.getElementById(`${side}CancelBtn`).classList.add('hidden');
            document.getElementById(`${side}ReadyBtn`).disabled = false;
            document.getElementById(`${side}ReadyBtn`).textContent = side === 'day' ? 'Create Game' : 'Join Game';
          });
          
          document.getElementById('matchInfo').classList.add('hidden');
          document.getElementById('startBtn').classList.add('hidden');
        }

        function startGame() {
          if (!currentGameId) {
            showError('No active game! Please create or join a game first.');
            return;
          }
          
          // Hide betting section and start game
          bettingSectionElement.classList.add('hidden');
          startBtnElement.classList.add('hidden');
          
          gameRunning = true;
          gameStartTime = Date.now();
          
          // Start game loop
          gameInterval = setInterval(draw, 1000 / 100); // 100 FPS
          
          // Start timer
          timerInterval = setInterval(updateTimer, 100);
        }

        function updateTimer() {
          const elapsed = Date.now() - gameStartTime;
          const remaining = Math.max(0, gameDuration - elapsed);
          
          if (remaining <= 0) {
            endGame();
            return;
          }
          
          const seconds = Math.ceil(remaining / 1000);
          const minutes = Math.floor(seconds / 60);
          const remainingSeconds = seconds % 60;
          
          timerElement.textContent = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
          
          // Add urgency color when time is running out
          if (remaining < 10000) { // Last 10 seconds
            timerElement.style.color = '#FF0000';
            timerElement.style.animation = 'blink 0.5s infinite';
          } else if (remaining < 30000) { // Last 30 seconds
            timerElement.style.color = '#FF9932';
          }
        }

        async function endGame() {
          gameRunning = false;
          clearInterval(gameInterval);
          clearInterval(timerInterval);
          
          // Determine winner
          let winner, winnerClass, message;
          let contractWinner = 0; // 0 = None, 1 = Day, 2 = Night, 3 = Tie
          
          if (dayScore > nightScore) {
            winner = "DAY WINS!";
            winnerClass = "winner-day";
            message = "The light has conquered the darkness!";
            contractWinner = 1; // Day
          } else if (nightScore > dayScore) {
            winner = "NIGHT WINS!";
            winnerClass = "winner-night";
            message = "Darkness has consumed the light!";
            contractWinner = 2; // Night
          } else {
            winner = "TIE GAME!";
            winnerClass = "";
            message = "The eternal balance remains!";
            contractWinner = 3; // Tie
          }
          
          // Show game over screen
          winnerTextElement.textContent = winner;
          winnerTextElement.className = winnerClass;
          finalScoreElement.textContent = `Final Score - Day: ${dayScore} | Night: ${nightScore}`;
          winMessageElement.textContent = message;
          
          // Show blockchain payout message
          document.getElementById('betResults').innerHTML = `
            <div style="color: #FFC801;">‚è≥ Processing blockchain payout...</div>
            <div style="font-size: 14px;">Winner will receive ETH automatically via smart contract</div>
          `;
          
          gameOverElement.style.display = 'flex';
          
          // Note: In a real implementation, the contract owner would call announceWinner()
          // For demo purposes, we'll just show the result
          console.log('üéÆ Game ended. Winner:', contractWinner, 'Game ID:', currentGameId);
        }

        function restartGame() {
          gameOverElement.style.display = 'none';
          bettingSectionElement.classList.remove('hidden');
          timerElement.style.color = '#FF9932';
          timerElement.style.animation = 'none';
          
          resetBettingUI();
          initializeGame();
          updateBalance(); // Refresh balance in case of payout
        }

        // Game Functions (keeping original game logic)
        function initializeGame() {
          // Reset squares
          for (let i = 0; i < numSquaresX; i++) {
            squares[i] = [];
            for (let j = 0; j < numSquaresY; j++) {
              squares[i][j] = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
            }
          }

          // Reset balls
          balls = [
            {
              x: canvas.width / 4,
              y: canvas.height / 2,
              dx: 8,
              dy: -8,
              reverseColor: DAY_COLOR,
              ballColor: DAY_BALL_COLOR,
            },
            {
              x: (canvas.width / 4) * 3,
              y: canvas.height / 2,
              dx: -8,
              dy: 8,
              reverseColor: NIGHT_COLOR,
              ballColor: NIGHT_BALL_COLOR,
            },
          ];

          dayScore = 0;
          nightScore = 0;
          gameRunning = false;
          
          // Draw initial state
          drawSquares();
          balls.forEach(drawBall);
          updateScore();
          timerElement.textContent = "1:00";
        }

        // Original game drawing functions
        function drawBall(ball) {
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, SQUARE_SIZE / 2, 0, Math.PI * 2, false);
          ctx.fillStyle = ball.ballColor;
          ctx.fill();
          ctx.closePath();
        }

        function drawSquares() {
          dayScore = 0;
          nightScore = 0;

          for (let i = 0; i < numSquaresX; i++) {
            for (let j = 0; j < numSquaresY; j++) {
              ctx.fillStyle = squares[i][j];
              ctx.fillRect(i * SQUARE_SIZE, j * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE);

              // Update scores
              if (squares[i][j] === DAY_COLOR) dayScore++;
              if (squares[i][j] === NIGHT_COLOR) nightScore++;
            }
          }
        }

        function updateScore() {
          scoreElement.textContent = `Day: ${dayScore} | Night: ${nightScore}`;
        }

        function checkSquareCollision(ball) {
          // Check multiple points around the ball's circumference
          for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
            const checkX = ball.x + Math.cos(angle) * (SQUARE_SIZE / 2);
            const checkY = ball.y + Math.sin(angle) * (SQUARE_SIZE / 2);

            const i = Math.floor(checkX / SQUARE_SIZE);
            const j = Math.floor(checkY / SQUARE_SIZE);

            if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
              if (squares[i][j] !== ball.reverseColor) {
                // Square hit! Update square color
                squares[i][j] = ball.reverseColor;

                // Determine bounce direction based on the angle
                if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
                  ball.dx = -ball.dx;
                } else {
                  ball.dy = -ball.dy;
                }
              }
            }
          }
        }

        function checkBoundaryCollision(ball) {
          if (ball.x + ball.dx > canvas.width - SQUARE_SIZE / 2 || ball.x + ball.dx < SQUARE_SIZE / 2) {
            ball.dx = -ball.dx;
          }
          if (ball.y + ball.dy > canvas.height - SQUARE_SIZE / 2 || ball.y + ball.dy < SQUARE_SIZE / 2) {
            ball.dy = -ball.dy;
          }
        }

        function addRandomness(ball) {
          ball.dx += Math.random() * 0.02 - 0.01;
          ball.dy += Math.random() * 0.02 - 0.01;

          // Limit the speed of the ball
          ball.dx = Math.min(Math.max(ball.dx, -MAX_SPEED), MAX_SPEED);
          ball.dy = Math.min(Math.max(ball.dy, -MAX_SPEED), MAX_SPEED);

          // Make sure the ball always maintains a minimum speed
          if (Math.abs(ball.dx) < MIN_SPEED) ball.dx = ball.dx > 0 ? MIN_SPEED : -MIN_SPEED;
          if (Math.abs(ball.dy) < MIN_SPEED) ball.dy = ball.dy > 0 ? MIN_SPEED : -MIN_SPEED;
        }

        function draw() {
          if (!gameRunning) return;
          
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawSquares();
          updateScore();

          balls.forEach((ball) => {
            drawBall(ball);
            checkSquareCollision(ball);
            checkBoundaryCollision(ball);
            ball.x += ball.dx;
            ball.y += ball.dy;

            addRandomness(ball);
          });
        }

        // Add CSS animation for blinking timer
        const style = document.createElement('style');
        style.textContent = `
          @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
          }
        `;
        document.head.appendChild(style);

        // Initialize the game
        initializeGame();

        // Set up event listeners
        const connectBtn = document.getElementById('connectWallet');
        const dayBtn = document.getElementById('dayReadyBtn');
        const nightBtn = document.getElementById('nightReadyBtn');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const dayCancelBtn = document.getElementById('dayCancelBtn');
        
        if (connectBtn) connectBtn.addEventListener('click', connectWallet);
        if (dayBtn) dayBtn.addEventListener('click', createGame);
        if (nightBtn) nightBtn.addEventListener('click', joinGame);
        if (startBtn) startBtn.addEventListener('click', startGame);
        if (restartBtn) restartBtn.addEventListener('click', restartGame);
        if (dayCancelBtn) dayCancelBtn.addEventListener('click', cancelGame);

        // Listen for account changes
        if (window.ethereum) {
          window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length === 0) {
              location.reload();
            } else {
              location.reload();
            }
          });

          window.ethereum.on('chainChanged', (chainId) => {
            location.reload();
          });
        }

        debug('App setup complete!');
      }

      // Debug function (global scope)
      function debug(message) {
        console.log('üîç DEBUG:', message);
        document.getElementById('debugText').textContent = message;
        document.getElementById('debugInfo').classList.remove('hidden');
      }

      function showError(message) {
        const errorDiv = document.getElementById('errorMessage');
        errorDiv.textContent = message;
        errorDiv.classList.remove('hidden');
        setTimeout(() => {
          errorDiv.classList.add('hidden');
        }, 5000);
      }

      // Start the app when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
      } else {
        initializeApp();
      }
    </script>
  </body>
</html>
